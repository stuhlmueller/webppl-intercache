// var bins = [0.01,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,
            // 0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,0.99]
var stateBins = _.range(0,0.999,0.01)
var thetaBins = _.range(0,0.999,0.01).slice(0,98)

// so that speaker2 only has one argument
var previter = 500
var prevprioriter = 100

console.log('inferring prevalence of property-category pairs...')
var prevalenceERP = Infer(
                    {
                      "method":"incrementalMH",
                      "samples":previter,
                      "verbose":"true",
                      "verboseLag":previter/10,
                      "burn": previter/2
                    },
                    prevalenceModel
                  )
console.log('prevalence of property-category pairs inferred!')

// reorganize prevalenceERP into a structured object
var prevalenceERPobject = _.object(map(function(p){
  var categories = _.uniq(_.pluck(subset(df_truth, "Property", p), "Category"))
  return [p, _.object(map(function(k){
    [k, marginalizeERP(prevalenceERP, [k,p])]
  }, categories))]
}, properties))


console.log('inferring prevalence priors...')
var priorERP = Infer(
                    {
                      "method":"incrementalMH",
                      "samples":prevprioriter,
                      "verbose":"true", 
                      "verboseLag":previter/10,
                      "burn": prevprioriter/2
                    },
                    priorModel
  )
console.log('prevalence priors inferred!')

// reorganize priorERP into a structured object
var priorERPobject = _.object(map(function(p){
  return [p, marginalizeERP(priorERP, p)]
}, properties))

// model produces "generic is true" vs. "mu"; data is as "agree-key" vs. "disagree-key"
var responseDictionary = {
  "agree-key":"generic is true",
  "disagree-key":"mu"
}

var property = properties[0]
var k = categories[0]
var priorProperty_ERP = priorERPobject[property]
var prior = priorProperty_ERP.MAP().val
var propertyData = subset(df_truth, "Property", property) // subset data
var responseData = _.pluck(subset(propertyData, "Category", k), "response")
var prevalencePropCat = prevalenceERPobject[property][k]
var prevalence = prevalencePropCat.MAP().val


var thetaPrior = function() {
  var threshold = uniformDraw(thetaBins)//something might go(?) wonky if "generic is false" can never be false
  return threshold
}

var statePrior = function(prior) {
  var state = stateBins[discrete(prior)]
  return state
}

var utterancePrior = function() {
   // var utterances = ["generic is true",
   //                  "generic is false"]
   var utterances = ["generic is true", "mu"]     
  return uniformDraw(utterances)
}

var meaning = function(utt,state, theta) {
  return _.isNumber(utt) ? state == utt :
  		   utt=="generic is true"? state>theta :
         utt=="generic is false"? state<=theta :
         utt=="some is true"? state>0 :
         utt=="some is false"? state==0 :
         utt=='mu'? true:
         utt=='some'? state>0:
         utt=='most'? state>= 0.5:
         utt=='all'? state >= 0.99:
         true
}

var listener0 = cache(function(utterance, theta, prior) {
  Enumerate(function(){
    var state = statePrior(prior)
    var m = meaning(utterance, state, theta)
    condition(m)    
    return state
  })
}, 1000)

var speaker1 = cache(function(state, theta, prior) {
  Enumerate(function(){
    var utterance = utterancePrior()
    var L0 = listener0(utterance, theta, prior)
    factor(L0.score(state))
    return utterance
  })
}, 1000)


var listener1 = function(utterance, prior, speakerOptimality) {
  Enumerate(function(){
    var state = statePrior(prior)
    var theta = thetaPrior()
    var S1 = speaker1(state, theta, prior)
    factor(speakerOptimality*S1.score(utterance))
    return state
  })
}

var speaker2 = function(speakerOptimality){
	Enumerate(function(){
		var utterance = utterancePrior()
		var L1 = listener1(utterance, prior, speakerOptimality)
		factor(L1.score(prevalence))
		return utterance
	})
}

var scoreSpeaker2 = function(speakerOptimality){
  var predictionERP = speaker2(speakerOptimality);
  var scr = sum(map(function(d) {
       return predictionERP.score(responseDictionary[d]);
    }, responseData));
  return scr;
};