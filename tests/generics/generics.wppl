// to run: webppl generics.wppl --require gen-utils --require .
var modelAnalysis = function(){
	// speakerOptimality is our continuous variable that wants to be intercached
	var speakerOptimality = uniform(0,20)
	/////////////////////////////////////
	// var t0 = genUtils.getTime()
	////SLOW FUNCTION////
 	var predictionERP = speaker2(speakerOptimality)

 	/////////////////////
	// var t1 = genUtils.getTime()
	// console.log("slow function call complete in " + (t1-t0) + " ms")
	
	var scr = sum(map(function(d) {
				    return predictionERP.score([], responseDictionary[d])
						}, responseData))
	factor(scr)

	query.add(["generic_linked",property, k, "0"], 
				Math.exp(predictionERP.score([], "generic is true")))
	query.add(["speakerOptimality","na","na","na"], speakerOptimality)

	return query
}

var modelAnalysisCached = function(){
	// speakerOptimality is our continuous variable that wants to be intercached
	var speakerOptimality = uniform(0,20)
	/////////////////////////////////////
	// var t0 = genUtils.getTime()
	////SLOW FUNCTION////
 	var predictionERP = speaker2Cached(speakerOptimality)
 	
 	/////////////////////
	// var t1 = genUtils.getTime()
	// console.log("slow function call complete in " + (t1-t0) + " ms")
	
	var scr = sum(map(function(d) {
				    return predictionERP.score(responseDictionary[d])
						}, responseData))
	factor(scr)

	query.add(["generic_linked",property, k, "0"], 
				Math.exp(predictionERP.score("generic is true")))
	query.add(["speakerOptimality","na","na","na"], speakerOptimality)

	return query
}

var mhiter = 2
var burn = mhiter/2
console.log('doing the full bayesian dance...')

var posterior = MCMC(modelAnalysis, {samples: mhiter, verbose:true, burnin:burn})

console.log('FBT complete')

// posterior
posterior
// var outfile = 'results/generics-previter'+previter+
// 				'_prevprioriter'+prevprioriter+
// 				'-IncrMH'+ mhiter+'_burn'+burn+'.csv'

// genUtils.erpWriter(posterior, outfile)
// console.log('wrote to... ' + outfile )

var speaker2Cached = interCache(speaker2, opts, makePolynomialFunction);
console.log("cached version");

var posteriorCached = MCMC(modelAnalysisCached, {samples: mhiter, verbose:true, burnin:burn});

//// below is the code for doing a for-loop
// var modelAnalysis = function(){

// 	// speakerOptimality is our continuous variable that wants to be intercached
// 	var speakerOptimality = uniform(0,20)

// 	var phi = 0 //note, there must be at least a tiny amount of noise, 
// 	// otherwise for the items with 0 prevalence, the model crashes


// 	// foreach(properties,
// 		// function(property){

// 			// var propertyData = subset(df_truth, "Property", property) // subset data
// 			// var categories = _.uniq(_.pluck(propertyData, "Category")) // each property has its own unique categories for which we have data

// 			// var priorProperty_ERP = priorERPobject[property]
// 			// var prior = sample(priorProperty_ERP)

// 			// foreach(categories,
// 				// function(k){

// 					// var responseData = _.pluck(subset(propertyData, "Category", k), "response")
					
// 					// var prevalencePropCat = prevalenceERPobject[property][k]
// 					// var prevalence = sample(prevalencePropCat)

// 					var t0 = genUtils.getTime()
// 					// SLOW FUNCTION
// 			     	var predictionERP = speaker2(prevalence, prior, speakerOptimality, 1)
// 					var t1 = genUtils.getTime()
// 					console.log("slow function call complete in " + (t1-t0) + " ms")

// 			     	// var linkedERP = guessingLink(predictionERP, phi)
					
// 					var scr = sum(map(function(d) {
// 								    return predictionERP.score([], responseDictionary[d])
// 										}, responseData))
// 					// console.log(scr)

// 					factor(scr)

// 					query.add(["generic_linked",property, k, "0"], 
// 								Math.exp(predictionERP.score([], "generic is true")))

// 				// })
// 		// })
// 	query.add(["speakerOptimality","na","na","na"], speakerOptimality)
// 	// query.add(["phi","na","na","na"], phi)

// 	return query
// }



	