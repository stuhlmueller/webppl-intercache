var mean = function(erp) {
  return expectation(erp, function(x) {return x;});
};

var variance = function(erp) {
  var m = mean(erp);
  return expectation(erp, function(x) { return (x - m) * (x - m); });
};


var interCache = function(slowFunc, options) {

  var state = {
    data: {
      inputs: [],
      outputs: []
    },
    guideParams: {}
  };

  var defaultParams = {
    offset: options.defaultOffset, //0,
    slope: options.defaultSlope //1
  };  

  
  var distOnFuncs = function(disableConditioning) {

    // Define slope/offset and parameterize based on guide params
    var offsetGuideMean = param(defaultParams.offset);
    var slopeGuideMean = param(defaultParams.slope);

    // Priors on offset and slope
    var offset = sample(gaussianERP, [options.offsetGaussianMean, options.offsetGaussianVar], { // 0, 5
      guide: [gaussianERP, [offsetGuideMean, options.offsetGuideVar]] // 0.5
    });
    var slope = sample(gaussianERP, [options.slopeGaussianMean, options.slopeGaussianVar], { // 0, 5
      guide: [gaussianERP, [slopeGuideMean, options.slopeGuideVar]] // 0.5
    });

    // Create function parameterized by offset and slope
    var f = function(x) {
      var y = x * slope + offset;
      return y;
    };

    if (!disableConditioning) {
      // Soft conditioning on input-output data
      var scores = map2(
        function(input, output){
          return gaussianERP.score([f(input), options.penaltyVariance], output); // 2
        },
        state.data.inputs,
        state.data.outputs);
      factor(sum(scores));
    }
    
    return f;
  };

  
  // Given argument, return distribution on return values
  var stochasticSurrogate = function(arg) {
    return SMC(
      function(){
        var f = distOnFuncs(true);
        return f(arg);
      }, {
        pparticles: options.returnValuesParticles, // 1000
        params: state.guideParams
      });
  }

  // Update state.guideParams using variational inference (based on all data points observed so far,
  // including new x-y pair)
  var updateParams = function(x, y) {
    // console.log('Updating params based on datapoint', x, y)
    var newParams = Optimize(distOnFuncs, {
      steps: options.optimizationSteps, // 1000
      method: {adagrad: {stepSize: options.stepSize }}, // 0.01
      estimator: 'ELBO',
      params: state.guideParams
    });
    // console.log(state.guideParams, '->', newParams)
    _.assign(state, { guideParams: newParams });
  }

  var fastFunc = function(arg, recordResult) {

    var distOnReturnVals = stochasticSurrogate(arg);  // don't condition on data here
    var returnValMean = mean(distOnReturnVals);
    var returnValVariance = variance(distOnReturnVals);

    var threshold = options.threshold; //.1

    // console.log({
    //   arg: arg,
    //   mean: returnValMean,
    //   variance: returnValVariance,
    //   greatherThanThreshold: returnValVariance > threshold
    // });

    if (returnValVariance > threshold) {
      var trueReturnVal = slowFunc(arg);
      state.data.inputs.push(arg);
      state.data.outputs.push(trueReturnVal);
      updateParams(arg, trueReturnVal);
      recordResult(arg, returnValMean, /*isCacheHit*/ false);
      return trueReturnVal;
    } else {
      // Record error relative to the actual result
      recordResult(arg, returnValMean, /*isCacheHit*/ true);
      return returnValMean;
    }
  };

  return fastFunc;
  
};


console.log('library.wppl loaded.');
