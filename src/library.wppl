var SHOW_DEBUG_INFO = false;

var cacheStates = webpplIntercache.cacheStates;


var mean = function(erp) {
  return expectation(erp, function(x) {return x;});
};

var variance = function(erp) {
  var m = mean(erp);
  return expectation(erp, function(x) { return (x - m) * (x - m); });
};

var makeLinearFunction = function(options) {
    // Define slope/offset and parameterize based on guide params
    var guideOffsetMean = param(options.guide.initialOffsetMean);
    var guideOffsetVar = param(options.guide.initialOffsetVar);
    var guideSlopeMean = param(options.guide.initialSlopeMean);
    var guideSlopeVar = param(options.guide.initialSlopeVar);

    // Priors on offset and slope
    var offset = sample(gaussianERP, [options.prior.offsetMean, options.prior.offsetVar], {
      guide: [gaussianERP, [guideOffsetMean, guideOffsetVar]]
    });
    var slope = sample(gaussianERP, [options.prior.slopeMean, options.prior.slopeVar], {
      guide: [gaussianERP, [guideSlopeMean, guideSlopeVar]]
    });

    // Create function parameterized by offset and slope
    return function(x) {
      var y = x * slope + offset;
      return y;
    };
};


// Note: priorFunc calls the param function, which means that it must *only* be called
// in distOnFuncs
var interCache = function(slowFunc, options, priorFunc) {

  var state = cacheStates.add({
    data: {
      inputs: [],
      outputs: []
    },
    guideParams: {},
    run: {
      samplePrediction: false,
      argument: null
    }
  });

  var distOnFuncs = function() {

    var f = priorFunc(options);
    
    if (state.get('run').samplePrediction) {
      // Return output of function applied to argument
      return f(state.get('run').argument);  // TODO: learn regressionVariance, add it here
      
    } else {
      // Soft conditioning on input-output data
      var scores = map2(
        function(input, output){
          return gaussianERP.score([f(input), options.regressionVariance], output); // 2
        },
        state.get('data').inputs,
        state.get('data').outputs);
      factor(sum(scores));

      // Return function
      return f;
    }
  };

  
  // Given argument, return distribution on return values
  var stochasticSurrogate = function(arg) {
    state.set('run', { samplePrediction: true, argument: arg });
    var marginal = SampleGuide(distOnFuncs, {
      samples: options.prediction.samples,
      params: state.get('guideParams')
    });
    return marginal;
  };

  // Update state.guideParams using variational inference (based on all data points observed so far,
  // including new x-y pair)
  var updateParams = function(x, y) {
    // console.log('Updating params based on datapoint', x, y)
    state.set('run', { samplePrediction: false, argument: null });
    var newParams = Optimize(distOnFuncs, {
      steps: options.optimization.steps,
      method: {adagrad: {stepSize: options.optimization.stepSize }},
      estimator: 'ELBO',
      params: state.get('guideParams')
    });
    // console.log(state.guideParams, '->', newParams)
    state.set('guideParams', newParams);
  }

  var fastFunc = function(arg, makeResult) {
    var distOnReturnVals = stochasticSurrogate(arg);  // don't condition on data here
    var returnValMean = mean(distOnReturnVals);
    var returnValVariance = variance(distOnReturnVals);

    if (SHOW_DEBUG_INFO) {
      var _trueReturnVal = slowFunc(arg);
      console.log('\nError:', Math.abs(returnValMean - _trueReturnVal));
      console.log('                Argument:', arg);
      console.log('  Estimated return value:', returnValMean);
      console.log('     Estimation variance:', returnValVariance);
      console.log('       True return value:', _trueReturnVal);
      console.log('                  Params:', state.get('guideParams'));
    }

    if (returnValVariance > options.threshold) {
      // console.log('miss');
      var trueReturnVal = slowFunc(arg);
      state.get('data').inputs.push(arg);
      state.get('data').outputs.push(trueReturnVal);
      updateParams(arg, trueReturnVal);
      return makeResult(arg, trueReturnVal, /*isCacheHit*/ false);
    } else {
      // console.log('hit');
      // Record error relative to the actual result
      return makeResult(arg, returnValMean, /*isCacheHit*/ true);
    }
  };

  return fastFunc;
  
};

console.log('library.wppl loaded.');
